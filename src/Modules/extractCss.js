const path = require('path');

/**
 * The plugin module to extract the CSS and source map from asset.
 *
 * @note If webpack mode is `production` then `css-loader` minify the CSS self,
 *   if webpack mode is `development` then CSS is pretty formatted.
 *
 * @type {ModuleOptions}
 */

const extractCss = {
  test: /\.(css|scss|sass|less|styl)$/,
  enabled: true,
  verbose: false,
  verboseHeader: 'Extract CSS',
  sourcePath: null,
  outputPath: null,
  filename: '[name].css',
  // inline CSS
  isInline: false,

  /**
   * Extract CSS and source map.
   *
   * @note The @import handling in CSS is not supported, e.g.: @import 'assets/css/style.css'.
   * Disable @import at-rules handling in `css-loader`:
   * {
   *   test: /\.(css|scss)$/i,
   *   use: [
   *     {
   *       loader: 'css-loader'
   *       options: {
   *         import: false, // disable @import at-rules handling
   *       },
   *     },
   *     'sass-loader',
   *   ],
   * },
   *
   * @param {array} sourceMaps
   * @param {string} assetFile
   * @param {Compilation} compilation
   * @returns {string}
   * @private
   */
  extract(sourceMaps, assetFile, compilation) {
    const { compiler } = compilation;
    const { RawSource, ConcatSource } = compiler.webpack.sources;
    const { devtool } = compiler.options;
    const isInlineSourceMap = devtool && devtool.startsWith('inline-');
    const concatMapping = new ConcatSource();

    let contentCSS = '';
    let contentMapping = '';
    let hasMapping = false;
    let mapFile;
    let file = '';

    for (const item of sourceMaps) {
      if (!Array.isArray(item)) continue;

      const [sourceFile, content, media, sourceMap, supports, layer] = item;

      if (contentCSS) contentCSS += '\n';

      // when in SCSS is used import of CSS file, like `@import url('./style.css');`
      // then `sourceFile` is null and `content` contains the output CSS filename
      if (sourceFile == null && content.endsWith('.css')) {
        contentCSS += `@import url(${content});`;
        continue;
      }

      contentCSS += content;

      if (sourceMap) {
        if (isInlineSourceMap || this.isInline) {
          const sourceURLs = sourceMap.sources
            .map((source) => '/*# sourceURL=' + (sourceMap.sourceRoot || '') + source + ' */')
            .join('\n');
          const base64 = Buffer.from(JSON.stringify(sourceMap)).toString('base64');
          contentMapping +=
            '\n' + sourceURLs + '\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64 + ' */';
        } else {
          concatMapping.add(new RawSource(JSON.stringify(sourceMap)));
        }
        hasMapping = true;
      }

      if (!file && sourceFile) file = sourceFile;
    }

    if (hasMapping) {
      if (isInlineSourceMap || this.isInline) {
        contentCSS += contentMapping;
      } else {
        mapFile = assetFile + '.map';
        contentCSS += `\n/*# sourceMappingURL=${path.basename(mapFile)} */`;
        compilation.emitAsset(mapFile, concatMapping);
      }
    }

    return contentCSS;
  },

  /**
   * The post process for extracted CSS content.
   * This method can be overridden in module options.
   *
   * @note The content is readonly!
   *   The CSS content should don't be change, because it has already the compiled source map.
   *
   * @param {string} content The css content generated by css-loader.
   * @param {ResourceInfo} info
   * @param {Compilation} compilation
   * @return {string|null}
   */
  // postprocess(content, info, compilation) {
  //   // the content here should be readonly
  //   if (this.verbose) {
  //     console.log(info);
  //   }
  //   return content;
  // },
};

/**
 * @param {ModuleOptions|{}} options The custom options.
 * @return {ModuleOptions} Default options merged with custom options.
 */
module.exports = (options = {}) => ({ ...extractCss, ...options });
